\documentclass[journal,12pt,twocolumn]{IEEEtran}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage{forest}
\usepackage{setspace}
\usepackage{gensymb}
\singlespacing


\usepackage{amsthm}

\usepackage{mathrsfs}
\usepackage{txfonts}
\usepackage{stfloats}
\usepackage{bm}
\usepackage{cite}
\usepackage{cases}
\usepackage{subfig}

\usepackage{longtable}
\usepackage{multirow}

\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{steinmetz}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage{tfrupee}
\usepackage[breaklinks=true]{hyperref}
\usepackage{graphicx}
\usepackage{tkz-euclide}

\usetikzlibrary{calc,math}
\usepackage{listings}
    \usepackage{color}                                            %%
    \usepackage{array}                                            %%
    \usepackage{longtable}                                        %%
    \usepackage{calc}                                             %%
    \usepackage{multirow}                                         %%
    \usepackage{hhline}                                           %%
    \usepackage{ifthen}                                           %%
    \usepackage{lscape}     
\usepackage{multicol}
\usepackage{chngcntr}

\DeclareMathOperator*{\Res}{Res}

\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}


\hyphenation{op-tical net-works semi-conduc-tor}
\def\inputGnumericTable{}                                 %%

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}
\begin{document}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{definition}[problem]{Definition}

\newcommand{\BEQA}{\begin{eqnarray}}
\newcommand{\EEQA}{\end{eqnarray}}
\newcommand{\define}{\stackrel{\triangle}{=}}
\bibliographystyle{IEEEtran}
\raggedbottom
\setlength{\parindent}{0pt}
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
% \providecommand{\abs}[1]{\left\vert#1\right\vert}
% \providecommand{\res}[1]{\Res\displaylimits_{#1}} 
% \providecommand{\norm}[1]{\left\lVert#1\right\rVert}
% %\providecommand{\norm}[1]{\lVert#1\rVert}
% \providecommand{\mtx}[1]{\mathbf{#1}}
% \providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
%\providecommand{\hilbert}{\overset{\mathcal{H}}{ \rightleftharpoons}}
\providecommand{\system}{\overset{\mathcal{H}}{ \longleftrightarrow}}
	%\newcommand{\solution}[2]{\textbf{Solution:}{#1}}
\newcommand{\solution}{\noindent \textbf{Solution: }}
\newcommand{\cosec}{\,\text{cosec}\,}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\numberwithin{equation}{subsection}
\makeatletter
\@addtoreset{figure}{problem}
\makeatother
\let\StandardTheFigure\thefigure
\let\vec\mathbf
\renewcommand{\thefigure}{\theproblem}
\def\putbox#1#2#3{\makebox[0in][l]{\makebox[#1][l]{}\raisebox{\baselineskip}[0in][0in]{\raisebox{#2}[0in][0in]{#3}}}}
     \def\rightbox#1{\makebox[0in][r]{#1}}
     \def\centbox#1{\makebox[0in]{#1}}
     \def\topbox#1{\raisebox{-\baselineskip}[0in][0in]{#1}}
     \def\midbox#1{\raisebox{-0.5\baselineskip}[0in][0in]{#1}}
\vspace{3cm}
\title{Assignment 1}
\author{Harsha Vardhan - EE18BTECH11018}
\maketitle
\newpage
\bigskip
\renewcommand{\thefigure}{\theenumi}
\renewcommand{\thetable}{\theenumi}
Download all latex-tikz codes from 
%
\begin{lstlisting}
https://github.com/harshagv9/C_DataStructures/blob/main/assignment1.tex
\end{lstlisting}
\section{Problem}
(Q 49) Consider the following ANSI C program.
\begin{lstlisting}
#include <stdio.h>
int foo(int x,int y, int q)
{
    if ((x<=0) && (y <= 0)) 
        return q;
    if (x <=0)
        return foo(x, y-q, q);
    if (y <= 0)
        return foo(x-q, y, q);
    return foo(x, y-q, q) + foo(x-q, y, q);
}
int main()
{
    int r = foo(15,15,10);
    printf("%d", r);
    return 0;
}
\end{lstlisting}
The output of the program upon execution is 
\section{Solution}
Answer : 60
\newline
\newline
\textbf{Explanation}
\newline
\newline
This is a problem involving recursion.
The function foo gets executed recursively until the values of x and y are negative in the foo function and finally returns the value of q. Hence final value of output depends on the number of recursive foo functions at the end. 
\newline
\newline
\newline
\newline
\newline
\newline
Initally at x = 15, y = 15, the inside block gets neglected and again foo functions gets executed.
\newline
\newline
Now two foo functions each with x,y are (5, 15),  (15, 5) are executed.
foo(15,15,10) =  foo(5,15,10) + foo(15,5,10)
\newline
\newline
foo(5,15,10)   =  foo(-5,15,10) + foo(5,-5,10)
\newline
\newline
foo(15,5,10)   =  foo(15,-5,10) + foo(5,5,10)
\newline
\newline
foo(5,5,10)  =  foo(5,-5,10) + foo(-5,5,10)
\newline
\newline
foo(-5,15,10)   =  foo(-5,5,10) = foo(-5,-5,10) = 10
\newline
\newline
foo(5,-5,10)   =  foo(-5,-5,10)  = 10
\newline
\newline
foo(-5,15,10)  = foo(-5,5,10)  = foo(-5,-5,10) = 10
\newline
\newline
foo(15,-5,10)  = foo(5,-5,10)  = foo(-5,-5,10) = 10
\newline
\newline
Hence adding the return values of all foo functions result = 60
\newline
\newline
\textbf{Mathematical Analysation}
\newline
\newline
This problem can be viewed as no of unique paths down the tree one has to travel so to get basic unit pair of numbers. i.e, the no of combinations for each pair taken a single number and obtaining the remainder each time until we get basic pair of least negative numbers.
\newpage
  \tikzset{
    every label/.append style={font=\scriptsize},
    my edge labels/.style={font=\scriptsize},
    dominant/.append style={label=below:$dominant$},
  }
  
  
  For any two random integers x,y the answer will always be some mulitple of q
given by following equation foo(x, y, q) 


\begin{equation*}
  foo(x,y,q) = ({\dfrac{( \ceil*{\frac{x}{q}} + \ceil*{\frac{y}{q}} ) ! } {(\ceil*{\frac{x}{q}} !)( \ceil*{\frac{y}{q}}! ) }}) * q
\end{equation*}




  \begin{forest}
    for tree={
      circle,
      draw,
      minimum width=2.5em,
      l sep+=1.5em,
      s sep+=1em,
      anchor=center,
      edge path={
        \noexpand\path[\forestoption{edge}](!u.parent anchor)--(.child anchor)[my edge labels]\forestoption{edge label};
      },
    },
    delay={
      where n=1{
        edge label/.wrap 2 pgfmath args={
          node[midway, left]{}}{level}{n}
      }{
        edge label/.wrap 2 pgfmath args={
          node[midway, right]{}}{level}{n}
      },
    }
    [10 [15 15 [5 15 [-5 15 [-5 5[-5 -5] ] ][5 5[-5 5[-5 -5]][5 -5[-5 -5]]] ] [15 5 [5 5[-5 5[-5 -5]] [5 -5[-5 -5]]][15 -5 [5 -5[-5 -5] ]] ] ]]
  \end{forest}
  
  
\end{document}
\end{document}
